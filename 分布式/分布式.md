`介绍和分布式架构`   
重要的`进程`   
`进程间通信`，通信打破独立运行涉及`同步`协作和相互`资源的访问`  
!`复制副本`（可靠性可扩展性和性能（服务器负载，地理位置，访问的便捷）导致`一致性`问题（更新的传播，副本同样的修改更新  
!`容错`（容忍错误发生故障仍能运行，从故障中恢复）（出现问题！！！）

分布式系统的目标：
用户资源+4

中间件：在应用程序和分布式平台的一层（透明性）

# 进程 
区别：系统单位/轻量级重量级切换/共享，通信/包含关系
进程：执行中的程序，程序的实例
线程：多线程技术，通信和本地处理并行，提高性能/线程阻塞的不会阻塞进程

服务器：提供服务的进程
迭代服务器，并发服务器
客户定位/绑定服务器：1. 2.超级服务器
带外数据
状态无关/有关服务器

服务器集群
三层结构，TCP转发



进程迁移/通信传递数据（进程，执行的进程）->代码迁移
本地资源
异构型

# 通信
基本知识
OSI7（3+1+3）
5+中间件


通信中间件通信的类型：1持久非持久（发送的消息被存储在中间件中直到被接收方接收 2异步同步 3离散消息 流式消息
通信模型：RPC，RMI（透明性，同步阻塞），MOM面向消息的中间件-消息队列（持久异步），流（音频视频连续媒体的通信，有限时间内持续的消息流）+多播
都基于底层消息传递

RPC（适用于客户服务器分布式系统组织形式，
基本过程，变体：两步异步的RPC-延迟的同步RPC
正常后效果目标：隐层通信，使远程调用好像本地调用
本身困难：1.机器差异，消息（参数结果）的传递复杂  2.两个程序运行在不同机器上，不同地址空间
可能出现问题：5种(1+2+2/流程顺序)
IDL
动态绑定



socket是个通信端点（基于通信协议，操作系统分配资源）：应用程序通过socket向底层网络发送或者读取数据
socket原语：图
套接字和MPI，消息队列（支持时间要求宽松的消息传输）
MOM消息队列：每个应用程序都有自己的消息队列（或者共享一个）用来接收，发送方可以发送消息加到接收方的消息队列中（只保证加入队列，不保证时间，不保证对方读取
提供消息的存储能力，只和队列打交道，双方完全独立运行，不需要双方都激活（）


消息队列的基本接口：put get poll notify
队列管理器（和应用程序交互）
消息中必须包含目标队列名-->需要知道队列和网络位置的映射关系：1.数据库存储，查询 队列管理器动态维护/静态拓扑不方便变换和管理  2.了解网络拓扑结构的路由器，只需要知道最近的路由器位置
消息转换器：应用网关，本质是个数据库（存储专家规则），对于队列是个应用程序，把消息转换为应用程序能理解的格式

面向流的通信
对时间敏感的信息即连续媒体的信息，提供对数据流的支持
数据流的传输模式：1.异步传输模式 2.同步传输模式 3.等时传播模式

等时传输的数据流-流：简单流，复杂流（包含多个子流（本身以及之间都是时间敏感的）
流与服务质量：1，描述特性 2.保证服务质量（网络层：确保行服务（定义了各种数据包的优先级，区分时间敏感 分布式系统：缓冲区减少抖动but开始延时（回放间隔，增大缓冲区，数据包丢失大间隔：更大的缓冲区开始延时+交错传输：如果丢失包，帧分布间隔广）

### 多播：可靠多播，应用层多播，基于gossip的通信
应用层多播基本思想：节点组织成覆盖网络（覆盖网络的构建：组织成树/组织 成网状网络（更健壮
chord建立多播树
开启多播的节点
1）生成一个多播标识符mid
2）查找succ（mid）的节点，作为多播树的根节点
想要加入多播的节点
运行lookup（mid）：请求加入多播组mid的信息从该节点路由到succ(mid)
中间经过多个节点，下一节点Q，Q没见过mid，Q成为转发器，记录P为孩子继续转发，以此类推，
如果见过即已成为转发器，仅记录不转发，结束
最终树的节点（2种类型），多播信息沿着树传播
（应用层多播未必高效，质量度量：链接树，相对延迟补偿，树成本

gossip：
类似人类世界
术语：已感染，易感染，已隔离的（新旧数据：序号时间戳）
前提假设：能随机其他节点即节点互联（做不到也不必要：定期更新节点的部分视图）
两种模型：
1）anti-entrpy：P随机选择节点Q更新（3，push在更新节点多时不好，少时好） --O(log(N))轮快速可扩展
2）流言传播：如果对方是已更新的，以1/k的概率变成隔离的，不再继续传播更新--不能保证全部被更新和k有关，k越大易感染的占比越小

简单有效，but问题：删除数据？将删除作为一次更新记录-死亡证书-冗余问题-死亡证书+时间戳后删除+少部分永久保存（收到旧值，再传播死亡证书
应用：（1，0初始化，稳定后1/N）求平均值，得到网络规模

进程的通信->进程间的同步协作：事件顺序同步，互斥访问

分布式系统没有全局共享时钟，每个机器有自己的时间
通信->交互就要时钟同步：物理时间一致/逻辑顺序一致（绝对时间下先后）

时钟同步：
lamport时间戳-全序多播
向量时间戳-因果序多播
进程知道了发生几个事件，消息m之前已经发生了什么先后关系

互斥访问：至多一个进程访问共享资源
选举算法：通常进程协作者，协作者崩溃时/点对点系统选举超级点




## 复制的原因和结果
## 一致性模型及一致性协议（实现）
以数据为中心的一致性模型，以客户为中心的一致性模型（简单的可实现的
放松一致性要求：一致性模型(要这样/建模，不一定有解）
严格一致性：任何读操作都能读取到最新的修改，换句话说，要求任何写操作都立刻同步到其他所有进程。这里强调的是绝对时钟上的立刻同步，而任何信息的同步都需要延迟，因此在分布式系统下无法严格实现。
持续一致性：数值偏差，新旧偏差，顺序偏差
线性一致性，所有节点上事件发生的的顺序全部一样，且和全局时间上时间发生的顺序一致
顺序一致性，所有节点上事件发生的的顺序全部一样，但是可能和全局时间上发生的顺序不一致
相比顺序一致性，因果一致性去掉了那些没有联系的操作需达成一致顺序观点的要求，只保留了那些必要的顺序
FIFO一致性：要求同一个进程的更新操作被其他所有进程看到的顺序是相同的。但是不同进程的几个操作被其他所有进程看到的顺序可能是不同的
入口一致性：把数据和同步化变量关联
（理解，副本数据/绝对时间线，什么东西是必须保证顺序的，读是写顺序的反应！！！！）

最终一致性：如果很长时间没有更新操作，所有副本逐渐一致，（只要求更新能传播到所有副本上）
以客户为中心的一致性模型：只为单一用户提供访问的一致性，不保证不同用户并发访问的一致性
问题：单一副本操作√，不同副本操作×

要什么样
单调读模型：不会读到更早的版本
单调写：副本数据项的写操作顺序一样
读写一致性：副本数据项的写更新都能被后续读看见
写读一致性：基于最新读到的值写

一致性协议(一致性模型的实现)

## 复制（副本）的管理：
1.副本放置 
2.副本一致性（更新的传播）
实际传播的信息内容，更新基于推/拉（比较表格）


一个协作者，单点失效
顺序一致性：主备份协议（每个数据项有一个主备份副本，更新操作在主副本上进行再传播：远程写协议，本地写协议，结合）
复制的写协议（更新操作在多个副本上进行）：主动复制（更新传播到所有副本，保证操作的顺序：全序的多播机制：lampart时间戳，定序器），基于多数表决的协议（读写操作需要请求多个服务器得到许可（读团体/写团体的原子性：2-读写冲突/写写冲突（only无读读））多种变形：半数+1，ROWA）


## 容错-可信系统：容错

可靠性系统特征,故障类型
发生错误-处理故障：冗余（信息：加信息/时间：重发/物理：三倍模块冗余，复制多备份几个投票）
分布式系统：进程故障，通信故障（有多种故障，主要的是崩溃性故障和遗漏性故障）
### 进程故障
进程容错：复制进程（目的：一个进程失败，其他进程代替接管/方法：）组织成组（目的：组的概率把进程集合形成单一概念。方法：）
进程组的复制-组织方式：
（复制：主备份协议）：等级组（单点失败问题）
（复制：复制的写协议）平等组（分布式协调的代价）---->（`可靠多播`）

`可靠多播`：消息可靠的发送给多个接收者（进程组里所有进程）
基本方法：（数目较少时）多个可靠点对点通信：发送方反馈拥塞--只反馈否认：不确保避免拥塞+长久缓存--无等级反馈控制（随机等待，反馈抑制--后续：独立编组共享反馈消息重发通道/本地恢复其他接收方分享消息）----分等级的反馈控制（组织成树，子组协作者+用小的可靠多播）
可扩展可靠多播，接收方规模
更严格的
`原子多播`：no or all，相同顺序
虚拟同步多播：消息崩溃前发出，要么全接收要么忽略，所有多播都在视图(|组状态)改变之间进行，不能跨越视图
更一般的问题（通用性！！）
`分布式提交`：no or all，相同顺序
单阶段提交协议：设立协作者，无法处理其他节点失败
两阶段提交协议（阻塞提交协议）：正常情况-4(2×2)/状态机  异常情况的阻塞处理，但不能处理所有参与者ready等待最终协议时协作者崩溃的情况，在协作者恢复前参与者持续阻塞
三阶段提交协议：协作者和参与者状态满足两个条件--！所以进入precommit状态相当于commit了，所有必同意（没有init）/已经形成了最终决策/一定是要提交的、（除非阻塞）



`K容错`：一次性最多容忍K个错误
沉默失败：K+1
拜占庭失败（故障继续运行）：至少2K+1（K+K+1）~3K+1画图题/多数决策！
拜占庭问题：尔虞我诈欺骗对应发生故障错误

`故障检测`：1节点主动探测其他节点(ping ping不通看其他) 2.定期告知邻节点(可用信息很旧说明故障)

### 通信故障

RPC
正常：隐层通信，使远程调用好像本地调用
出现问题：5种(1+2+2/流程顺序)
1.无法定位：\
2.请求消息丢失：定时器重发即可
3.服务器崩溃：！
3.应答丢失：无法判断到底情况没收到，幂等性？：简单重发+序列号
5.客户端崩溃：孤儿进程

## 可靠多播
## 分布式提交

## 系统恢复
1.回退恢复：设置检查点
2.前向恢复：必须预知可能发生的错误
代价--结果
性能和效果

检查点
独立检查点：简单效果不好：恢复性计算困难，不能组成分布式快照多米诺效应
协调检查点：效果好性能问题（1分布式快照 2.简单：2PC）
少的检查点配合消息日志：记录系统操作，发生错误时从检查点状态开始，重现系统操作

共性问题和解决方案：
中间件
进程 机器 节点
网络通信 中间件层
都基于底层消息传递
生成消息 系统调用操作系统-
消息 网络 本地操作系统 中间缓存接收 应用程序/进程
lamport在中间层

任何问题：故障处理：3冗余
任何协同操作：分布式提交（123PC的本质）
重发序列号

中心协作者和分布式处理
单点失败问题（性能瓶颈，可扩展性）vs分布式协调的代价
复杂性，代价，代价守恒，好的算法代价转换后的部分小



操作银行和打印的例子幂等非幂等
任意缓慢的进程和崩溃的进程,网络故障还是节点故障
本质问题，思想迁移


框架逻辑正向推
知识点反向？？
